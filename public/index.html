<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>TEste</title>
    <link rel="stylesheet" href="main.css"> 
</head>
<body>
    <script src="/socket.io/socket.io.js"></script>
    <script src="/assets/libs/FBXLoader.js"></script>
    <script src="/assets/libs/three.min.js"></script>
    <script src="/assets/libs/inflate.min.js"></script>
    <script src="/assets/libs/FBXLoader.js"></script>
    <script src="/assets/libs/OrbitControls.js"></script>
    <script src="/assets/libs/Detector.js"></script>
    
	
    <script type="module">
        //import { GLTFLoader } from './assets/GLTFLoader.js'
        let socket = io.connect('http://18.231.176.38:3000/')
        let idG = ""
        let players = []
        let sqm = 50
        let coordenadasJogador = []
        let xCamera = 25
        let yCamera = 500
        let zCamera = 700

        let xCameraLook = 25
        let yCameraLook = 100
        let scene = new THREE.Scene();

        socket.on('escolhaClasse', function(id) {
            
            idG = id
            /*
            
            let classe = prompt('Em qual ciencia do combate deseja se especializar? [mago], [ladino], [cavaleiro]').toUpperCase()
            if(classe == 'MAGO'){
                socket.emit('classe', {
                    resp:'MAGO',
                    id: id
            })
            }
            else{
                alert('escreva apenas o nome da especializacao que quer seguir...')
                location.reload()
            }
            */
            
        })
        socket.on('moveBlocked', function(id) {
            console.log('your normal MOVE was BLOCKED')
        })
        socket.on('finalTurno', function() {
            if(idG.length > 2){
                socket.emit('puxarUpdate', {id: idG})
            }
        })
        socket.on('update', function(newPositions) {
            console.log(newPositions.x + "newPositions.x <<")
            console.log(newPositions.y + "newPositions.y <<")
            if(newPositions.x !== coordenadasJogador[0] || newPositions.y !== coordenadasJogador[1]){
                camera.position.set(xCamera + newPositions.x*sqm, zCamera, yCamera + newPositions.y*sqm)
                camera.lookAt(new THREE.Vector3(xCameraLook + newPositions.x*sqm, 20, yCameraLook + newPositions.y*sqm))
                coordenadasJogador[0] = newPositions.x
                coordenadasJogador[1] = newPositions.y
            }
            cube.position.x = newPositions.x*sqm + 25
            cube.position.z = newPositions.y*sqm + 25 

            cube2.position.x = newPositions.x*sqm + 25
            cube2.position.z = newPositions.y*sqm + 25 

            cube3.position.x = newPositions.x*sqm + 25
            cube3.position.z = newPositions.y*sqm + 25 
            for (let i = 0; i < newPositions.resp.length; i++) {
                let c = 0
                for (let ii = 0; ii < players.length; ii++) {
                    if(players[ii].nome == newPositions.resp[i].nome){
                        players[ii].cube.position.x = newPositions.resp[i].x*sqm + 25
                        players[ii].cube.position.z = newPositions.resp[i].y*sqm + 25

                        players[ii].cube2.position.x = newPositions.resp[i].x*sqm + 25
                        players[ii].cube2.position.z = newPositions.resp[i].y*sqm + 25

                        players[ii].cube3.position.x = newPositions.resp[i].x*sqm + 25
                        players[ii].cube3.position.z = newPositions.resp[i].y*sqm + 25
                        // mexer
                    }
                    else{
                        c = c + 1
                    }
                    
                }
                if(c == players.length){
                    //add new PLAYER
                    let geometry = new THREE.BoxGeometry(10,10,10)
                    let material = new THREE.MeshBasicMaterial( {color: 0xff0000 } )
                
                    let cube = new THREE.Mesh( geometry, material )
                    let cube2 = new THREE.Mesh( geometry, material )
                    let cube3 = new THREE.Mesh( geometry, material )
                    cube.position.x = newPositions.resp[i].x
                    cube.position.y = 25
                    cube.position.z = newPositions.resp[i].y
                    scene.add(cube)

                    cube2.position.x = newPositions.resp[i].x
                    cube2.position.y = 50
                    cube2.position.z = newPositions.resp[i].y
                    scene.add(cube2)
                    
                    cube3.position.x = newPositions.resp[i].x
                    cube3.position.y = 75
                    cube3.position.z = newPositions.resp[i].y
                    scene.add(cube3)
                    players.push({
                        nome: newPositions.resp[i].nome,
                        cube: cube,
                        cube2: cube2,
                        cube3: cube3
                    })
                }
                
            }
            let novosCubos = []
            for (let i = 0; i < newPositions.length; i++) {
                for (let ii = 0; ii < players.length; ii++) {
                    
                    
                }
                
            }
        })

        let camera =  new THREE.PerspectiveCamera( 45, window.innerWidth/window.innerHeight,1,2500)

        

        camera.position.set(20, 560, 400)
        camera.lookAt(new THREE.Vector3(20, 10, 100))

        let renderer = new THREE.WebGLRenderer({antialias: true})
        renderer.setClearColor("#e5e5e5")
        renderer.setSize(window.innerWidth, window.innerHeight)

        document.body.appendChild(renderer.domElement)

        

        window.addEventListener('resize', () => {
            renderer.setSize(window.innerWidth, window.innerHeight);
            camera.aspect = window.innerWidth / window.innerHeight;

            camera.updateProjectionMatrix();
        })
        //const loader = new OBJLoader();
/*
// load a resource
loader.load(
	// resource URL
	'objetos/Stone_Wall_1.obj',
	// called when resource is loaded
	function ( object ) {

		scene.add( object );

	},
	// called when loading is in progresses
	function ( xhr ) {

		console.log( ( xhr.loaded / xhr.total * 1 ) + '% loaded' );

	},
	// called when loading has errors
	function ( error ) {

		console.log( 'An error happened' );

	}
);
*/
        document.addEventListener ('keypress', (event) => {
            const keyName = event.key;
            if(event.key == 'ctrl'){
                socket.emit('run', {id: idG})
            }

            if(event.key == 'w'){
                socket.emit('move', {id: idG, resp: "w"})
                
                

                /*
                    cube.position.x = cube.position.x
                    cube.position.y = cube.position.y
                    cube.position.z = cube.position.z - sqm

                    cube2.position.x = cube2.position.x
                    cube2.position.y = cube2.position.y
                    cube2.position.z = cube2.position.z - sqm

                    cube3.position.x = cube3.position.x
                    cube3.position.y = cube3.position.y
                    cube3.position.z = cube3.position.z - sqm
                */                    
                
            }
            if(event.key == 's'){
                socket.emit('move', {id: idG, resp: "s"})


                /*
                cube.position.x = cube.position.x
                cube.position.y = cube.position.y
                cube.position.z = cube.position.z + sqm

                cube2.position.x = cube2.position.x
                cube2.position.y = cube2.position.y
                cube2.position.z = cube2.position.z + sqm
                
                cube3.position.x = cube3.position.x
                cube3.position.y = cube3.position.y
                cube3.position.z = cube3.position.z + sqm
                */
            }
            if(event.key == 'a'){
                socket.emit('move', {id: idG, resp: "a"})
                /*
                cube.position.x = cube.position.x - sqm
                cube.position.y = cube.position.y
                cube.position.z = cube.position.z

                cube2.position.x = cube2.position.x - sqm
                cube2.position.y = cube2.position.y
                cube2.position.z = cube2.position.z
                
                cube3.position.x = cube3.position.x - sqm
                cube3.position.y = cube3.position.y
                cube3.position.z = cube3.position.z
                */
                
            }
            if(event.key == 'd'){
                socket.emit('move', {id: idG, resp: "d"})
                /*
                cube.position.x = cube.position.x + sqm
                cube.position.y = cube.position.y
                cube.position.z = cube.position.z

                cube2.position.x = cube2.position.x + sqm
                cube2.position.y = cube2.position.y
                cube2.position.z = cube2.position.z
                
                cube3.position.x = cube3.position.x + sqm
                cube3.position.y = cube3.position.y
                cube3.position.z = cube3.position.z
                */
                
           
            }
            if(event.key == 'q'){
                socket.emit('move', {id: idG, resp: "q"})
               
            }
            if(event.key == 'e'){
                socket.emit('move', {id: idG, resp: "e"})
               
            }
            if(event.key == 'z'){
                socket.emit('move', {id: idG, resp: "z"})
            
            }
            if(event.key == 'c'){
                socket.emit('move', {id: idG, resp: "c"})
             
            }
            if(event.key == 'b'){
                /*
                const geometry = new THREE.SphereGeometry( 50, 32, 32 );
                const material = new THREE.MeshBasicMaterial( {color: 0xffff00} );
                const sphere = new THREE.Mesh( geometry, material );
                sphere.position.x = cube.position.x
                sphere.position.y = cube.position.y + 120 + 300*Math.random()
                sphere.position.z = cube.position.z
                scene.add( sphere );
                */
                
            }
            
        });
               
               
                

            
           
                
                let geometry = new THREE.BoxGeometry(10,10,10)
                let material = new THREE.MeshBasicMaterial( {color: 0xFFCC00} )
                
                let cube = new THREE.Mesh( geometry, material )
                let cube2 = new THREE.Mesh( geometry, material )
                let cube3 = new THREE.Mesh( geometry, material )
                cube.position.x = 25
                cube.position.y = 25
                cube.position.z = 25
                scene.add(cube)

                cube2.position.x = 25
                cube2.position.y = 50
                cube2.position.z = 25
                scene.add(cube2)
                
                cube3.position.x = 25
                cube3.position.y = 75
                cube3.position.z = 25
                scene.add(cube3)
                players.push({
                        nome: `teste`,
                        cube: cube,
                        cube2: cube2,
                        cube3: cube3
                    })

                
           
            
        

        

        
        
        let light = new THREE.HemisphereLight( 0xffffff, 0x444444 );
        light.position.set( 0, 200, 0)
        scene.add( light )

        light = new THREE.DirectionalLight( 0xffffff );
        light.position.set( 0, 200, 100);
        light.castShadow = true;
        light.shadow.camera.top = 180;
        light.shadow.camera.bottom = -100;
        light.shadow.camera.left = -120;
        light.shadow.camera.right = 120;
        scene.add( light )

        //ground

        let mesh = new THREE.Mesh( new THREE.PlaneBufferGeometry( 2000, 2000), new THREE.MeshPhongMaterial( { color: 0x999999, depthWrite: false }));
        mesh.rotation.x = - Math.PI / 2
        mesh.receiveShadow = true
        scene.add( mesh )

        let grid = new THREE.GridHelper( 2000, 40, 0x000000, 0x000000)
        grid.material.opacity = 0.2;
        grid.material.transparent = true;
        scene.add(grid)
        //let loader = new GLTFLoader()
        //loader.load( 'assets/scene.gltf', function (gltf) {
          
            //scene.add(gltf.scene)
        //} )
        const loader = new THREE.FBXLoader();
		const game = this;
        let t
        let tt
        let t1
        let tt1
		
		loader.load( `/assets/modelos/fbx/people/FireFighter.fbx`, function ( object ) {

			object.mixer = new THREE.AnimationMixer( object );
			t = object.mixer;
			tt = object.mixer.getRoot();
			
			object.name = "FireFighter";
					
			object.traverse( function ( child ) {
				if ( child.isMesh ) {
					child.castShadow = true;
					child.receiveShadow = false;		
				}
			} );
			
            const tLoader = new THREE.TextureLoader();
            tLoader.load(`/assets/modelos/images/SimplePeople_FireFighter_Brown.png`, function(texture){
				object.traverse( function ( child ) {
					if ( child.isMesh ){
						child.material.map = texture;
					}
				} );
			});
            
			scene.add(object);
			t.clipAction(object.animations[0]).play();
            
            //game.animate();
		} );

        loader.load( `/assets/modelos/fbx/people/Character.fbx`, function ( object ) {

object.mixer = new THREE.AnimationMixer( object );
t1 = object.mixer;
tt1 = object.mixer.getRoot();

object.name = "Character";
        
object.traverse( function ( child ) {
    if ( child.isMesh ) {
        child.castShadow = true;
        child.receiveShadow = false;		
    }
} );

object.position.x = 800
object.position.y = 50
object.position.z = 300


scene.add(object);

//t1.clipAction(object.animations[0]).play();

//game.animate();
} );

		const animate = function () {

			requestAnimationFrame( animate );
         
                cube.rotation.x += 0.1*Math.random()-0.05
                cube.rotation.y += 0.1*Math.random()-0.05

                cube2.rotation.x += 0.1*Math.random()-0.05
                cube2.rotation.y += 0.1*Math.random()-0.05

                cube3.rotation.x += 0.1*Math.random()-0.05
                cube3.rotation.y += 0.1*Math.random()-0.05

                for(let i = 0; i < players.length; i++){                    
                    players[i].cube.rotation.x += 0.1*Math.random()-0.05
                    players[i].cube.rotation.y += 0.1*Math.random()-0.05

                    players[i].cube2.rotation.x += 0.1*Math.random()-0.05
                    players[i].cube2.rotation.y += 0.1*Math.random()-0.05

                    players[i].cube3.rotation.x += 0.1*Math.random()-0.05
                    players[i].cube3.rotation.y += 0.1*Math.random()-0.05
                }
         
            
			renderer.render( scene, camera );
			
            };

			animate();

        

        
        

        
    </script>
</body>
</html>